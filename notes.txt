1. dyrektywa ngModel - przypisywanie wartości wpisanej w inpucie do atrybutu klasy
trzeba wrzucić import FormsModule w module komponentu

.ts
name = ""

.html
<input [(ngModel)]="name" >
<p>{{name}}</p>

2. deklaracja, rozszerza coś o dodatkowe elementy

@Component({
  selector: 'app-server',
  templateUrl: './server.component.html',
  styleUrls: ['./server.component.scss']
})

3. String interpolation - wyrażenia, które na końcu
printują string/konwersje na string, mogą to być jakieś pola klasy

<div>{{ title }}</div>

4.  property binding - nawiasy kwadratowe - sygnalizują dynamiczne bindowanie do domyślnych atrybutów elementu html

<button [disabled]="!allowNewServers">

Interpolacja stringów zadziała tylko raz, ale nie będzie dynamicznych zmian (poniżej)
<button disabled="{{ !allowNewServers }}" >

5. Event binding - eventy przypisujemy w nawiasach okrągłych, bez "on": onClick="źle", (onclick)="dobrze"
  
  <button(click)="onCreateServer()">

6. Passing data with event binding - poprzez użycie słowa kluczowego $event w parametrze metody obsługującej event,
mamy dostep do danych wyemitowanych razem z tym eventem

<input (input)="onUpdateServerName($event)" />

  onUpdateServerName(event: Event) {
    this.serverName = (<HTMLInputElement>event.target).value;
  }

7. Two way data binding - Działa w dwie strony, zmiana pola klasy zmienia wartość, event w inpucie zmienia pole
<input type="text" [(ngModel)]="name" />

Poniżej: Jednokierunkowe bindowanie - event zmieni zmienną, ale value inputa nie zmieni się gdy zmienimy w innym miejscu pole klasy
<input (input)="onUpdateServerName($event)" />

8. Directives - dyrektywy to instrukcje w DOM
Komponenty to dyrektywy z szablonem - nakazują stworzenie komponentu <app-component> z szablonu

9. *ngIf directive - dyrektywa *ngIf to coś w rodzaju if statement. Gwiazdka oznacza, że to dyrektywa strukturalna, czyli modyfikuje DOM.
  <p *ngIf="serverCreated">{{ serverCreationStatus }}</p>

10. *ngIf with else

  <p *ngIf="serverCreated; else noServer">{{ serverCreationStatus }}</p>
  <ng-template> #noServer>
    <p>No server. ng-template to wbudwany komponent/dyrektywa</p>
  </ng-template>

11. ngStyle directive - dyrektywa atrybutu - nie dodaje/usuwa elementów DOM, modyfikuje tylko element na którym jest obecna
sama dyrektywa pisana jest bez [], ale tu jest property binding
Dodaje pojedyncze style na bazie jakiegoś warunku

<p [ngStyle]="{backgroundColor: getColor()}">test</p>

  getColor() {
    return this.serverStatus === 'online' ? 'green' : 'red';
  }

[ngStyle] without method

<p [ngStyle]="{ backgroundColor: serverStatus === 'online' ? 'green' : 'red' }">test</p>

12. ngClass directive - dyrektywa atrybutu,
Dodaje klasy na podstawie jakiegoś warunku

<p [ngClass]="{online: serverStatus === 'online'}">test</p>
Klasa bez kropki i bez cudzysłowia

13. *ngFor directive - dyrektywa strukturalna, umożliwa loopowanie po tablicy, przypomina zastosowaniem map z reacta

  servers: string[] = ['Testserver1', 'Testserver2'];
  <app-server *ngFor="let server of servers">{{server}} - dostep do elementu tablicy z konkretnego wywołania</app-server>

Można również wyciągnąc indeks danej iteracji

  <p *ngFor="let click of clicks; let i = index">
    {{ clicks[i] }}
  </p>

14. Bingding to custom properties - passing data between components
Aby przekazać dane z rodzica do dziecka, w html rodzica dodajemy bindowanie atrybutu, a w dziecku dodajemy @Input (wraz z importem)

PARENT:
  <app-server *ngFor="let server of servers" [server]="server"></app-server>

CHILD:
import z anuglar-core

@Input() server: string = "";

<p>
  Server with ID {{server}}
</p>

15. Binding to custom properties with alias name in the outer component

PARENT:
  <app-server *ngFor="let server of servers" [SRV]="server"></app-server>

CHILD:
import z anuglar-core

@Input('SRV') server: string = "";

<p>
  Server with ID {{server}}
</p>

16. Emiting custom events - w dziecku html reagujemy na normalny wbudowany event, w ts emitujemy nowy event
w rodzicu reagujemy na customowy event poprzez kolejną metodę, w parametrze mamy dostęp do $eventu czyli danych z customowoego eventu

PARENT:
<app-cockpit
  (serverCreated)="onServerAdded($event)"
></app-cockpit>

serverElements = [{type: 'server', name: 'TestServer', content: 'just a test'}]

    onServerAdded(serverData: {serverName: string, serverContent: string}) {
    this.serverElements.push({
      type: 'server',
      name: serverData.serverName,
      content: serverData.serverContent,
    });
  }

CHILD:
<button class="btn btn-primary" (click)="onAddServer()">Add Server</button>

import output z angular-core

  newServerName: string = '';
  newServerContent: string = '';

  @Output() serverCreated = new EventEmitter<{
    serverName: string;
    serverContent: string;
  }>();

    onAddServer() {
    this.serverCreated.emit({
      serverName: this.newServerName,
      serverContent: this.newServerContent,
    });
  }

17. Emiting custom events with alias name in the outer component

CHILD:
  @Output('srvCreated') serverCreated = new EventEmitter<{
    serverName: string;
    serverContent: string;
  }>();

PARENT:
  <app-cockpit
    (srvCreated)="onServerAdded($event)"
  ></app-cockpit>